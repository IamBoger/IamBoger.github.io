<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/haqi.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/haqi.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"iamboger.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本篇为对Java面向对象编程思想学习的下篇 本篇文章内容包含：static关键字、单例设计模式、main方法、代码块、final关键字、抽象类和抽象方法、匿名对象、模板方法设计模式、接口、代理模式、内部类">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象编程（下）">
<meta property="og:url" content="https://iamboger.github.io/2023/12/15/16-09-21/index.html">
<meta property="og:site_name" content="Boger&#39;s Blog">
<meta property="og:description" content="本篇为对Java面向对象编程思想学习的下篇 本篇文章内容包含：static关键字、单例设计模式、main方法、代码块、final关键字、抽象类和抽象方法、匿名对象、模板方法设计模式、接口、代理模式、内部类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://iamboger.github.io/images/illustration/c9b6ec0bb43e45709f6c20aaf5d271ba.png">
<meta property="og:image" content="https://iamboger.github.io/images/illustration/e6c0da4b1abb43a399a4f1cfa2659271.png">
<meta property="article:published_time" content="2023-12-15T08:09:21.000Z">
<meta property="article:modified_time" content="2023-12-17T14:58:09.280Z">
<meta property="article:author" content="Boger">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iamboger.github.io/images/illustration/c9b6ec0bb43e45709f6c20aaf5d271ba.png">


<link rel="canonical" href="https://iamboger.github.io/2023/12/15/16-09-21/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://iamboger.github.io/2023/12/15/16-09-21/","path":"2023/12/15/16-09-21/","title":"面向对象编程（下）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面向对象编程（下） | Boger's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Boger's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Show me the code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">单例设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#main%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">main方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">4.</span> <span class="nav-text">代码块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">5.</span> <span class="nav-text">final关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">抽象类和抽象方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.</span> <span class="nav-text">创建抽象类的匿名对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">模板方法设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="nav-number">9.</span> <span class="nav-text">接口(interface)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy"><span class="nav-number">10.</span> <span class="nav-text">代理模式(Proxy)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">内部类</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Boger"
      src="/uploads/haqi.jpg">
  <p class="site-author-name" itemprop="name">Boger</p>
  <div class="site-description" itemprop="description">Hachiware is my Hero</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:1149646297@qq.com" title="E-Mail → mailto:1149646297@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/106296671" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;106296671" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douyin.com/user/MS4wLjABAAAABn1T7QZfUyMAw-EDO0xIEpOAjN7HO5sglwo0rCPYURLZurwdwPtomZ8SkNd2DePd" title="抖音 → https:&#x2F;&#x2F;www.douyin.com&#x2F;user&#x2F;MS4wLjABAAAABn1T7QZfUyMAw-EDO0xIEpOAjN7HO5sglwo0rCPYURLZurwdwPtomZ8SkNd2DePd" rel="noopener me" target="_blank"><i class="fa custom douyin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/QQ1149646297?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;QQ1149646297?type&#x3D;blog" rel="noopener me" target="_blank"><i class="fa custom csdn fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://iamboger.github.io/2023/12/15/16-09-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/haqi.jpg">
      <meta itemprop="name" content="Boger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boger's Blog">
      <meta itemprop="description" content="Hachiware is my Hero">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="面向对象编程（下） | Boger's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面向对象编程（下）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-15 16:09:21" itemprop="dateCreated datePublished" datetime="2023-12-15T16:09:21+08:00">2023-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-17 22:58:09" itemprop="dateModified" datetime="2023-12-17T22:58:09+08:00">2023-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本篇为对Java面向对象编程思想学习的下篇</p>
<p>本篇文章内容包含：static关键字、单例设计模式、main方法、代码块、final关键字、抽象类和抽象方法、匿名对象、模板方法设计模式、接口、代理模式、内部类</p>
<span id="more"></span>

<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份，例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<p>static关键字的使用：</p>
<ol>
<li><p>static：静态的</p>
</li>
<li><p>static可以用来修饰：属性、方法、代码块、内部类</p>
</li>
<li><p>使用static修饰属性：静态变量（类变量）</p>
<ul>
<li>属性按是否使用static修饰分为：静态属性vs非静态属性（实例变量）<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都独立拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li>
</ul>
</li>
<li>static修饰属性的其他说明：<ol>
<li>静态变量随着类的加载而加载。可以通过<code>类.静态变量</code>的方式进行调用</li>
<li>静态变量的加载要早于对象的创建</li>
<li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的的静态域中</li>
<li><table>
<thead>
<tr>
<th align="center">能否调用</th>
<th align="center">类变量</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li>静态属性举例：<code>System.out</code> ; <code>Math.PI</code>;</li>
</ul>
</li>
<li><p>使用static修饰方法：静态方法</p>
<ol>
<li>随着类的加载而加载，可以通过<code>类.静态方法</code>的方式进行调用</li>
<li><table>
<thead>
<tr>
<th align="center">能否调用</th>
<th align="center">静态方法</th>
<th align="center">非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
</li>
<li>静态方法中，只能调用静态的方法或属性</li>
<li>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li>
</ol>
</li>
<li><p>static注意点：</p>
<ol>
<li>在静态的方法中，不能使用this关键字、super关键字</li>
<li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解</li>
<li>静态方法只能访问类中的静态变量</li>
</ol>
</li>
<li><p>开发中，如何确定一个属性是否要声明为static的？</p>
<ul>
<li><p>属性是可以被多个对象所共享的，不会随着对象的不同而不同</p>
</li>
<li><p>类中的常量常常声明为static的</p>
</li>
</ul>
</li>
<li><p>开发中，如何确定一个方法是否声明为static的？</p>
<ul>
<li><p>操作静态属性的方法，通常设置为static的</p>
</li>
<li><p>工具类中的方法，习惯上声明为static的，比如：Math、Arrays、Collections</p>
</li>
</ul>
</li>
</ol>
<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>单例(Singleton)设计模式：</p>
<p>设计模式<strong>是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式</strong>。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。</p>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的<strong>构造器的访问权限设置为private</strong>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能<strong>调用该类的某个静态方法</strong>以返回类内部创建的对象，<strong>静态方法只能访问类中的静态成员变量</strong>，所以，指向类内部产生的<strong>该类对象的变量也必须定义成静态的</strong>。</p>
<p>单例模式的优点：</p>
<p>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</p>
<p>单例设计模式的饿汉式实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1、私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//2、内部创建类的对象，要求此对象也必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="comment">//3、提供公共的静态方法，返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例设计模式的懒汉式实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="comment">// 1、私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、声明当前类对象，没有初始化，此对象也必须声明为static的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 3、提供公共的静态方法，返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区分饿汉式和懒汉式：</p>
<p>饿汉式：</p>
<ul>
<li>好处 –&gt; 线程安全</li>
<li>坏处 –&gt; 对象加载时间过长</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>好处 –&gt; 延迟对象的创建</li>
<li>坏处 –&gt; 目前的写法是线程不安全的 –&gt; 到多线程内容时，再修改</li>
</ul>
<p>笔试中如果没说明写哪种单例设计模式，则两种方式都可以写，但如果要写懒汉式的写法注意需要写修改后的线程安全版本。</p>
<h1 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h1><p>main()方法的使用说明：</p>
<ol>
<li>main()方法作为程序的入口</li>
<li>main()方法也是一个普通的静态方法</li>
<li>main()方法可以作为我们与控制台交互的方式（之前使用Scanner）<ul>
<li>如何将控制台获取的数据传给形参：<code>String[] args</code></li>
<li>运行时：java 类名 参数列表</li>
<li>例如：java Test “Tom” “Jerry” “123”</li>
</ul>
</li>
</ol>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>代码块（初始化块）</p>
<ol>
<li><p>代码块的作用：用来初始化类、对象</p>
</li>
<li><p>代码块如果有修饰的话，只能使用static</p>
</li>
<li><p>分类：静态代码块 vs 非静态代码块</p>
</li>
<li><p>静态代码块</p>
<ul>
<li><p>随着类的加载而执行，而且只执行一次</p>
</li>
<li><p>作用：初始化类的信息</p>
</li>
<li><p>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p>
</li>
<li><p>静态代码块的执行要优先于非静态代码块的执行</p>
</li>
<li><p>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p>
</li>
</ul>
</li>
<li><p>非静态代码块</p>
<ul>
<li><p>随着对象的创建而执行</p>
</li>
<li><p>每创建一个对象，就执行一次非静态代码块</p>
</li>
<li><p>作用：可以在创建对象时，对对象的属性等进行初始化</p>
</li>
<li><p>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</p>
</li>
<li><p>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p>
</li>
</ul>
</li>
</ol>
<p>对属性可以赋值的位置：</p>
<ol>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器中初始化</li>
<li>有了对象以后，可以通过<code>对象.属性</code>或<code>对象.方法</code>的方式进行赋值</li>
<li>在代码块中赋值</li>
</ol>
<p><strong>代码块比构造器先执行</strong></p>
<p>代码块的执行顺序：由父及子，静态先行（先运行父类的代码块，静态的代码块都先执行）</p>
<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>单词final的含义：最终的</p>
<ol>
<li><p>final可以用来修饰的结构：类、方法、变量</p>
</li>
<li><p>final用来修饰一个类：此类不能被其他类所继承</p>
<p>比如：String类、System类、StringBuffer类</p>
</li>
<li><p>final用来修饰方法：表明此方法不可以被重写</p>
<p>比如：Object类中getClass()</p>
</li>
<li><p>final用来修饰变量：此时的“变量”就称为是一个常量</p>
<ul>
<li><p>final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</p>
</li>
<li><p>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</p>
</li>
</ul>
</li>
<li><p>static final用来修饰属性：全局常量</p>
</li>
</ol>
<h1 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h1><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<ol>
<li><p>abstract：抽象的</p>
</li>
<li><p>abstract可以用来修饰的结构：类、方法</p>
</li>
<li><p>abstract修饰类：抽象类</p>
<ul>
<li><p>此类不能实例化</p>
</li>
<li><p>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</p>
</li>
<li><p>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p>
</li>
</ul>
</li>
<li><p>abstract修饰方法：抽象方法</p>
<ul>
<li><p>抽象方法只有方法的声明，没有方法体</p>
</li>
<li><p>包含抽象方法的类一定是抽象类；反之，抽象类中可以没有抽象方法</p>
</li>
<li><p>若子类重写了父类中所有的抽象方法，此子类方可实例化；若子类没有重写父类中所有的抽象方法，则子类也是抽象类，需要用abstract修饰</p>
</li>
</ul>
</li>
</ol>
<p>abstract使用上的注意点：</p>
<ol>
<li>abstract不能用来修饰：属性、构造器等结构</li>
<li>abstract不能用来修饰私有方法、静态方法、final方法、final类</li>
</ol>
<h1 id="创建抽象类的匿名对象"><a href="#创建抽象类的匿名对象" class="headerlink" title="创建抽象类的匿名对象"></a>创建抽象类的匿名对象</h1><p>非匿名类的非匿名对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">method(worker);<span class="comment">//非匿名类的非匿名对象</span></span><br></pre></td></tr></table></figure>

<p>非匿名类的匿名对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="keyword">new</span> <span class="title class_">Worker</span>());<span class="comment">//非匿名类的匿名对象</span></span><br></pre></td></tr></table></figure>

<p>匿名子类的非匿名对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个匿名子类的非匿名对象</span></span><br><span class="line"><span class="comment">//Person是一个抽象类，eat方法和breath方法是抽象方法</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">method(p);</span><br></pre></td></tr></table></figure>

<p>匿名子类的匿名对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建匿名子类的匿名对象</span></span><br><span class="line">method(<span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h1><p>模板方法设计模式(TemplateMethod)</p>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p>解决的问题:</p>
<ul>
<li><p>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p>
</li>
<li><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
</li>
</ul>
<h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h1><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</p>
<p>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则必须能…”的思想。<strong>继承是一个”是不是”的关系，而接口实现则是”能不能”的关系。</strong></p>
<p>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</p>
<p>定义Java类的语法格式：先写extends，后写implements</p>
<ul>
<li><code>class SubClass extends SuperClass implements InterfaceA &#123; &#125;</code></li>
</ul>
<p>一个类可以实现多个接口，接口也可以继承其它接口。</p>
<p>实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。</p>
<p>接口的主要用途就是被实现类实现。(面向接口编程)</p>
<p>与继承关系类似，接口与实现类之间存在多态性</p>
<p>接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。</p>
<p>举例：</p>
<p>实线箭头为继承关系，虚线箭头为接口功能</p>
<img src="/images/illustration/c9b6ec0bb43e45709f6c20aaf5d271ba.png" alt="img" style="zoom: 50%;" />

<p>接口的使用：</p>
<ol>
<li><p>接口使用interface来定义</p>
</li>
<li><p>Java中，接口和类是并列的两个结构</p>
</li>
<li><p>如何定义接口：定义接口中的成员</p>
<ul>
<li><p>JDK7及以前：只能定义全局常量和抽象方法 </p>
<ul>
<li>全局常量：public static final (注意这些修饰符可以省略不写但仍然生效)</li>
<li>抽象方法：public abstract</li>
</ul>
</li>
<li><p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p>
</li>
</ul>
</li>
<li><p>接口中不能定义构造器，意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用</p>
<p>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</p>
<p>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</p>
</li>
<li><p>Java类可以实现多个接口 –&gt; 弥补了Java单继承性的局限性</p>
<p>格式：class AA extends BB implements CC, DD, EE</p>
</li>
<li><p>接口与接口之间可以继承(extends)，而且可以多继承</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
</li>
<li><p>接口实际上可以看做是一种规范</p>
</li>
<li><p>开发中，体会面向接口编程</p>
</li>
</ol>
<p>面试题：抽象类与接口有哪些异同？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建接口非匿名实现类的非匿名对象</span></span><br><span class="line"><span class="type">Flash</span> <span class="variable">flash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flash</span>();</span><br><span class="line">com.transferData(flash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建接口非匿名实现类的匿名对象</span></span><br><span class="line">com.transferData(<span class="keyword">new</span> <span class="title class_">Printer</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、创建接口的匿名实现类的非匿名对象</span></span><br><span class="line"><span class="type">USB</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">com.transferData(phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、创建了接口的匿名实现类的匿名对象</span></span><br><span class="line">com.transferData(<span class="keyword">new</span> <span class="title class_">USB</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Java8中接口的新特性：</p>
<p>除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p>
<ol>
<li><p>接口中定义的静态(static)方法，只能由接口去调用</p>
</li>
<li><p>通过实现类的对象，可以调用接口中的默认(default)方法(非静态方法)</p>
</li>
<li><p>如果实现类重写了接口中的默认方法，调用时仍然调用的是重写以后的方法</p>
</li>
<li><p>如果子类(或实现类)继承的父亲和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的方法 –&gt; 类优先原则</p>
</li>
<li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错 –&gt; 接口冲突</p>
</li>
<li><p>在子类(或实现类)的方法中调用父类、接口中被重写的方法：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> <span class="keyword">implements</span> <span class="title class_">CompareA</span>,CompareB&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">        <span class="built_in">super</span>.method3();<span class="comment">//调用的是父类中声明的方法</span></span><br><span class="line">        <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">        CompareA.<span class="built_in">super</span>.method3();</span><br><span class="line">        CompareB.<span class="built_in">super</span>.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h1><p>代理模式体现了接口的应用</p>
<p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p>
<img src="/images/illustration/e6c0da4b1abb43a399a4f1cfa2659271.png" alt="img" style="zoom: 50%;" /> 

<p>应用场景:</p>
<ul>
<li>安全代理：屏蔽对真实角色的直接访问。</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li>
</ul>
<p>比如要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。</p>
<p>分类：</p>
<ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）<ul>
<li>JDK自带的动态代理，需要反射等知识</li>
</ul>
</li>
</ul>
<p>代理举例：（本例为静态代理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">new</span> <span class="title class_">RealStar</span>());</span><br><span class="line">        s.confer();</span><br><span class="line">        s.signContract();</span><br><span class="line">        s.sing();</span><br><span class="line">        s.collectMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">confer</span><span class="params">()</span>;<span class="comment">// 面谈</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signContract</span><span class="params">()</span>;<span class="comment">// 签合同</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>;<span class="comment">// 唱歌</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">collectMoney</span><span class="params">()</span>;<span class="comment">// 收钱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealStar</span> <span class="keyword">implements</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signContract</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;明星：唱歌&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collectMoney</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Star real;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Star real)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.real = real;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;经纪人面谈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signContract</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;经纪人签合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        real.sing();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collectMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;经纪人收钱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 经纪人面谈</span></span><br><span class="line"><span class="comment">// 经纪人签合同</span></span><br><span class="line"><span class="comment">// 明星：唱歌  </span></span><br><span class="line"><span class="comment">// 经纪人收钱  </span></span><br></pre></td></tr></table></figure>

<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。</p>
<p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</p>
<p>lnner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</p>
<ul>
<li>Inner class的名字不能与包含它的外部类类名相同</li>
</ul>
<p>分类：</p>
<p>成员内部类（static成员内部类和非static成员内部类）</p>
<p>局部内部类（方法内、代码块内、构造器内，且不谈修饰符)、匿名内部类</p>
<p>成员内部类：</p>
<p>一方面，作为外部类的成员</p>
<ul>
<li>调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以被4种不同的权限修饰</li>
</ul>
<p>另一方面，作为一个类</p>
<ul>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li>
<li>可以被abstract修饰</li>
</ul>
<p>关注的3个问题：</p>
<blockquote>
<ol>
<li>如何实例化成员内部类的对象</li>
<li>如何在成员内部类中区分调用外部类的结构</li>
<li>开发中局部内部类的使用</li>
</ol>
</blockquote>
<ol>
<li>如何实例化成员内部类的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Dog实例(静态的成员内部类)</span></span><br><span class="line">        Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line">        dog.show();</span><br><span class="line">        <span class="comment">// 创建Bird实例(非静态的成员内部类)</span></span><br><span class="line">        <span class="comment">// Person.Bird bird = new Person.Bird();错误的</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人，吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态成员内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;卡拉是条狗&quot;</span>);</span><br><span class="line">            <span class="comment">// eat();不允许调用，因为该内部类是静态类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 方法体</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一只小小鸟&quot;</span>);</span><br><span class="line">            eat();<span class="comment">// 可以调用</span></span><br><span class="line">            Person.<span class="built_in">this</span>.eat();<span class="comment">// 调用外部类的非静态属性，效果与上一行一致</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p>卡拉是条狗</p>
<p>我是一只小小鸟</p>
<p>人，吃饭   </p>
<p>人，吃饭 </p>
</blockquote>
<ol start="2">
<li>如何在成员内部类中区分调用外部类的结构</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        bird.display(<span class="string">&quot;黄鹂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 非静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 方法体</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            System.out.println(name);<span class="comment">// 方法的形参</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);<span class="comment">// 内部类的属性</span></span><br><span class="line">            System.err.println(Person.<span class="built_in">this</span>.name);<span class="comment">// 外部类的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p>黄鹂</p>
<p>杜鹃</p>
<p>小明</p>
</blockquote>
<ol start="3">
<li>开发中局部内部类的使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开发中很少见</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">        <span class="comment">// class MyComparable implements Comparable&#123;</span></span><br><span class="line">        <span class="comment">//     public int compareTo(Object o)&#123;</span></span><br><span class="line">        <span class="comment">//         return 0;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return new MyComparable();</span></span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        <span class="comment">//创建了一个实现接口的匿名实现类的匿名对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部内部类使用时的一个注意点：</p>
<ul>
<li>在局部内部类的方法中如果调用局部内部类所声明的方法中的局部变量，要求此局部变量声明为final的。</li>
<li>JDK7及之前版本要求此局部变量显式地声明为final的</li>
<li>JDK8及之后的版本可以省略final的声明</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>Boger
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://iamboger.github.io/2023/12/15/16-09-21/" title="面向对象编程（下）">https://iamboger.github.io/2023/12/15/16-09-21/</a>
  </li>
  <li class="post-copyright-license">
      <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/13/20-12-49/" rel="prev" title="面向对象编程（中）">
                  <i class="fa fa-angle-left"></i> 面向对象编程（中）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/17/21-27-13/" rel="next" title="Java中的异常">
                  Java中的异常 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Boger</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
